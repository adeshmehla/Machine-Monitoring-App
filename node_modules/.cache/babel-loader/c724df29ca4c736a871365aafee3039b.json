{"ast":null,"code":"import _createForOfIteratorHelper from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/adesh/machine-maintence/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar e = /*#__PURE__*/function () {\n  function e(a, b, c, d, f) {\n    var _this = this;\n    _classCallCheck(this, e);\n    this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE;\n    this._preferredCamera = \"environment\";\n    this._maxScansPerSecond = 25;\n    this._lastScanTimestamp = -1;\n    this._destroyed = this._flashOn = this._paused = this._active = !1;\n    this.$video = a;\n    this.$canvas = document.createElement(\"canvas\");\n    c && \"object\" === typeof c ? this._onDecode = b : (c || d || f ? console.warn(\"You're using a deprecated version of the QrScanner constructor which will be removed in the future\") : console.warn(\"Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\"), this._legacyOnDecode = b);\n    b = \"object\" === typeof c ? c : {};\n    this._onDecodeError = b.onDecodeError || (\"function\" === typeof c ? c : this._onDecodeError);\n    this._calculateScanRegion = b.calculateScanRegion || (\"function\" === typeof d ? d : this._calculateScanRegion);\n    this._preferredCamera = b.preferredCamera || f || this._preferredCamera;\n    this._legacyCanvasSize = \"number\" === typeof c ? c : \"number\" === typeof d ? d : this._legacyCanvasSize;\n    this._maxScansPerSecond = b.maxScansPerSecond || this._maxScansPerSecond;\n    this._onPlay = this._onPlay.bind(this);\n    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n    this._updateOverlay = this._updateOverlay.bind(this);\n    a.disablePictureInPicture = !0;\n    a.playsInline = !0;\n    a.muted = !0;\n    var h = !1;\n    a.hidden && (a.hidden = !1, h = !0);\n    document.body.contains(a) || (document.body.appendChild(a), h = !0);\n    c = a.parentElement;\n    if (b.highlightScanRegion || b.highlightCodeOutline) {\n      d = !!b.overlay;\n      this.$overlay = b.overlay || document.createElement(\"div\");\n      f = this.$overlay.style;\n      f.position = \"absolute\";\n      f.display = \"none\";\n      f.pointerEvents = \"none\";\n      this.$overlay.classList.add(\"scan-region-highlight\");\n      if (!d && b.highlightScanRegion) {\n        this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\"><path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n        try {\n          this.$overlay.firstElementChild.animate({\n            transform: [\"scale(.98)\", \"scale(1.01)\"]\n          }, {\n            duration: 400,\n            iterations: Infinity,\n            direction: \"alternate\",\n            easing: \"ease-in-out\"\n          });\n        } catch (m) {}\n        c.insertBefore(this.$overlay, this.$video.nextSibling);\n      }\n      b.highlightCodeOutline && (this.$overlay.insertAdjacentHTML(\"beforeend\", '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);\n    }\n    this._scanRegion = this._calculateScanRegion(a);\n    requestAnimationFrame(function () {\n      var m = window.getComputedStyle(a);\n      \"none\" === m.display && (a.style.setProperty(\"display\", \"block\", \"important\"), h = !0);\n      \"visible\" !== m.visibility && (a.style.setProperty(\"visibility\", \"visible\", \"important\"), h = !0);\n      h && (console.warn(\"QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.\"), a.style.opacity = \"0\", a.style.width = \"0\", a.style.height = \"0\", _this.$overlay && _this.$overlay.parentElement && _this.$overlay.parentElement.removeChild(_this.$overlay), delete _this.$overlay, delete _this.$codeOutlineHighlight);\n      _this.$overlay && _this._updateOverlay();\n    });\n    a.addEventListener(\"play\", this._onPlay);\n    a.addEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n    document.addEventListener(\"visibilitychange\", this._onVisibilityChange);\n    window.addEventListener(\"resize\", this._updateOverlay);\n    this._qrEnginePromise = e.createQrEngine();\n  }\n  _createClass(e, [{\n    key: \"hasFlash\",\n    value: function () {\n      var _hasFlash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var a;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!this.$video.srcObject) {\n                _context.next = 7;\n                break;\n              }\n              if (this.$video.srcObject instanceof MediaStream) {\n                _context.next = 4;\n                break;\n              }\n              return _context.abrupt(\"return\", !1);\n            case 4:\n              a = this.$video.srcObject;\n              _context.next = 10;\n              break;\n            case 7:\n              _context.next = 9;\n              return this._getCameraStream();\n            case 9:\n              a = _context.sent.stream;\n            case 10:\n              return _context.abrupt(\"return\", \"torch\" in a.getVideoTracks()[0].getSettings());\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](0);\n              return _context.abrupt(\"return\", !1);\n            case 16:\n              _context.prev = 16;\n              a && a !== this.$video.srcObject && (console.warn(\"Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream\"), e._stopVideoStream(a));\n              return _context.finish(16);\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[0, 13, 16, 19]]);\n      }));\n      function hasFlash() {\n        return _hasFlash.apply(this, arguments);\n      }\n      return hasFlash;\n    }()\n  }, {\n    key: \"isFlashOn\",\n    value: function isFlashOn() {\n      return this._flashOn;\n    }\n  }, {\n    key: \"toggleFlash\",\n    value: function () {\n      var _toggleFlash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this._flashOn) {\n                _context2.next = 5;\n                break;\n              }\n              _context2.next = 3;\n              return this.turnFlashOff();\n            case 3:\n              _context2.next = 7;\n              break;\n            case 5:\n              _context2.next = 7;\n              return this.turnFlashOn();\n            case 7:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function toggleFlash() {\n        return _toggleFlash.apply(this, arguments);\n      }\n      return toggleFlash;\n    }()\n  }, {\n    key: \"turnFlashOn\",\n    value: function () {\n      var _turnFlashOn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused))) {\n                _context3.next = 13;\n                break;\n              }\n              _context3.prev = 1;\n              _context3.next = 4;\n              return this.hasFlash();\n            case 4:\n              if (_context3.sent) {\n                _context3.next = 6;\n                break;\n              }\n              throw \"No flash available\";\n            case 6:\n              _context3.next = 8;\n              return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{\n                  torch: !0\n                }]\n              });\n            case 8:\n              _context3.next = 13;\n              break;\n            case 10:\n              _context3.prev = 10;\n              _context3.t0 = _context3[\"catch\"](1);\n              throw this._flashOn = !1, _context3.t0;\n            case 13:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[1, 10]]);\n      }));\n      function turnFlashOn() {\n        return _turnFlashOn.apply(this, arguments);\n      }\n      return turnFlashOn;\n    }()\n  }, {\n    key: \"turnFlashOff\",\n    value: function () {\n      var _turnFlashOff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.t0 = this._flashOn;\n              if (!_context4.t0) {\n                _context4.next = 5;\n                break;\n              }\n              this._flashOn = !1;\n              _context4.next = 5;\n              return this._restartVideoStream();\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function turnFlashOff() {\n        return _turnFlashOff.apply(this, arguments);\n      }\n      return turnFlashOff;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.$video.removeEventListener(\"loadedmetadata\", this._onLoadedMetaData);\n      this.$video.removeEventListener(\"play\", this._onPlay);\n      document.removeEventListener(\"visibilitychange\", this._onVisibilityChange);\n      window.removeEventListener(\"resize\", this._updateOverlay);\n      this._destroyed = !0;\n      this._flashOn = !1;\n      this.stop();\n      e._postWorkerMessage(this._qrEnginePromise, \"close\");\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var _yield$this$_getCamer, a, b;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this._destroyed) {\n                _context5.next = 2;\n                break;\n              }\n              throw Error(\"The QR scanner can not be started as it had been destroyed.\");\n            case 2:\n              if (!(!this._active || this._paused)) {\n                _context5.next = 30;\n                break;\n              }\n              if (!(\"https:\" !== window.location.protocol && console.warn(\"The camera stream is only accessible if the page is transferred via https.\"), this._active = !0, !document.hidden)) {\n                _context5.next = 30;\n                break;\n              }\n              if (!(this._paused = !1, this.$video.srcObject)) {\n                _context5.next = 9;\n                break;\n              }\n              _context5.next = 7;\n              return this.$video.play();\n            case 7:\n              _context5.next = 30;\n              break;\n            case 9:\n              _context5.prev = 9;\n              _context5.next = 12;\n              return this._getCameraStream();\n            case 12:\n              _yield$this$_getCamer = _context5.sent;\n              a = _yield$this$_getCamer.stream;\n              b = _yield$this$_getCamer.facingMode;\n              if (!(!this._active || this._paused)) {\n                _context5.next = 19;\n                break;\n              }\n              e._stopVideoStream(a);\n              _context5.next = 24;\n              break;\n            case 19:\n              this._setVideoMirror(b);\n              this.$video.srcObject = a;\n              _context5.next = 23;\n              return this.$video.play();\n            case 23:\n              this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(function () {}));\n            case 24:\n              _context5.next = 30;\n              break;\n            case 26:\n              _context5.prev = 26;\n              _context5.t0 = _context5[\"catch\"](9);\n              if (this._paused) {\n                _context5.next = 30;\n                break;\n              }\n              throw this._active = !1, _context5.t0;\n            case 30:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[9, 26]]);\n      }));\n      function start() {\n        return _start.apply(this, arguments);\n      }\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.pause();\n      this._active = !1;\n    }\n  }, {\n    key: \"pause\",\n    value: function () {\n      var _pause = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        var _this2 = this;\n        var a,\n          b,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              a = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : !1;\n              this._paused = !0;\n              if (this._active) {\n                _context6.next = 4;\n                break;\n              }\n              return _context6.abrupt(\"return\", !0);\n            case 4:\n              this.$video.pause();\n              this.$overlay && (this.$overlay.style.display = \"none\");\n              b = function b() {\n                _this2.$video.srcObject instanceof MediaStream && (e._stopVideoStream(_this2.$video.srcObject), _this2.$video.srcObject = null);\n              };\n              if (!a) {\n                _context6.next = 9;\n                break;\n              }\n              return _context6.abrupt(\"return\", (b(), !0));\n            case 9:\n              _context6.next = 11;\n              return new Promise(function (c) {\n                return setTimeout(c, 300);\n              });\n            case 11:\n              if (this._paused) {\n                _context6.next = 13;\n                break;\n              }\n              return _context6.abrupt(\"return\", !1);\n            case 13:\n              b();\n              return _context6.abrupt(\"return\", !0);\n            case 15:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function pause() {\n        return _pause.apply(this, arguments);\n      }\n      return pause;\n    }()\n  }, {\n    key: \"setCamera\",\n    value: function () {\n      var _setCamera = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(a) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.t0 = a !== this._preferredCamera;\n              if (!_context7.t0) {\n                _context7.next = 5;\n                break;\n              }\n              this._preferredCamera = a;\n              _context7.next = 5;\n              return this._restartVideoStream();\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function setCamera(_x) {\n        return _setCamera.apply(this, arguments);\n      }\n      return setCamera;\n    }()\n  }, {\n    key: \"setGrayscaleWeights\",\n    value: function setGrayscaleWeights(a, b, c) {\n      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n      e._postWorkerMessage(this._qrEnginePromise, \"grayscaleWeights\", {\n        red: a,\n        green: b,\n        blue: c,\n        useIntegerApproximation: d\n      });\n    }\n  }, {\n    key: \"setInversionMode\",\n    value: function setInversionMode(a) {\n      e._postWorkerMessage(this._qrEnginePromise, \"inversionMode\", a);\n    }\n  }, {\n    key: \"_onPlay\",\n    value: function _onPlay() {\n      this._scanRegion = this._calculateScanRegion(this.$video);\n      this._updateOverlay();\n      this.$overlay && (this.$overlay.style.display = \"\");\n      this._scanFrame();\n    }\n  }, {\n    key: \"_onLoadedMetaData\",\n    value: function _onLoadedMetaData() {\n      this._scanRegion = this._calculateScanRegion(this.$video);\n      this._updateOverlay();\n    }\n  }, {\n    key: \"_onVisibilityChange\",\n    value: function _onVisibilityChange() {\n      document.hidden ? this.pause() : this._active && this.start();\n    }\n  }, {\n    key: \"_calculateScanRegion\",\n    value: function _calculateScanRegion(a) {\n      var b = Math.round(2 / 3 * Math.min(a.videoWidth, a.videoHeight));\n      return {\n        x: Math.round((a.videoWidth - b) / 2),\n        y: Math.round((a.videoHeight - b) / 2),\n        width: b,\n        height: b,\n        downScaledWidth: this._legacyCanvasSize,\n        downScaledHeight: this._legacyCanvasSize\n      };\n    }\n  }, {\n    key: \"_updateOverlay\",\n    value: function _updateOverlay() {\n      var _this3 = this;\n      requestAnimationFrame(function () {\n        if (_this3.$overlay) {\n          var a = _this3.$video,\n            b = a.videoWidth,\n            c = a.videoHeight,\n            d = a.offsetWidth,\n            f = a.offsetHeight,\n            h = a.offsetLeft,\n            m = a.offsetTop,\n            n = window.getComputedStyle(a),\n            p = n.objectFit,\n            k = b / c,\n            q = d / f;\n          switch (p) {\n            case \"none\":\n              var g = b;\n              var l = c;\n              break;\n            case \"fill\":\n              g = d;\n              l = f;\n              break;\n            default:\n              (\"cover\" === p ? k > q : k < q) ? (l = f, g = l * k) : (g = d, l = g / k), \"scale-down\" === p && (g = Math.min(g, b), l = Math.min(l, c));\n          }\n          var _n$objectPosition$spl = n.objectPosition.split(\" \").map(function (r, y) {\n              var x = parseFloat(r);\n              return r.endsWith(\"%\") ? (y ? f - l : d - g) * x / 100 : x;\n            }),\n            _n$objectPosition$spl2 = _slicedToArray(_n$objectPosition$spl, 2),\n            v = _n$objectPosition$spl2[0],\n            w = _n$objectPosition$spl2[1];\n          n = _this3._scanRegion.width || b;\n          q = _this3._scanRegion.height || c;\n          p = _this3._scanRegion.x || 0;\n          var u = _this3._scanRegion.y || 0;\n          k = _this3.$overlay.style;\n          k.width = \"\".concat(n / b * g, \"px\");\n          k.height = \"\".concat(q / c * l, \"px\");\n          k.top = \"\".concat(m + w + u / c * l, \"px\");\n          c = /scaleX\\(-1\\)/.test(a.style.transform);\n          k.left = \"\".concat(h + (c ? d - v - g : v) + (c ? b - p - n : p) / b * g, \"px\");\n          k.transform = a.style.transform;\n        }\n      });\n    }\n  }, {\n    key: \"_scanFrame\",\n    value: function _scanFrame() {\n      var _this4 = this;\n      !this._active || this.$video.paused || this.$video.ended || (\"requestVideoFrameCallback\" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var a, b, c;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (1 >= _this4.$video.readyState) {\n                _context8.next = 29;\n                break;\n              }\n              a = Date.now() - _this4._lastScanTimestamp, b = 1E3 / _this4._maxScansPerSecond;\n              _context8.t0 = a < b;\n              if (!_context8.t0) {\n                _context8.next = 6;\n                break;\n              }\n              _context8.next = 6;\n              return new Promise(function (d) {\n                return setTimeout(d, b - a);\n              });\n            case 6:\n              _this4._lastScanTimestamp = Date.now();\n              _context8.prev = 7;\n              _context8.next = 10;\n              return e.scanImage(_this4.$video, {\n                scanRegion: _this4._scanRegion,\n                qrEngine: _this4._qrEnginePromise,\n                canvas: _this4.$canvas\n              });\n            case 10:\n              c = _context8.sent;\n              _context8.next = 18;\n              break;\n            case 13:\n              _context8.prev = 13;\n              _context8.t1 = _context8[\"catch\"](7);\n              if (_this4._active) {\n                _context8.next = 17;\n                break;\n              }\n              return _context8.abrupt(\"return\");\n            case 17:\n              _this4._onDecodeError(_context8.t1);\n            case 18:\n              _context8.t2 = !e._disableBarcodeDetector;\n              if (_context8.t2) {\n                _context8.next = 25;\n                break;\n              }\n              _context8.next = 22;\n              return _this4._qrEnginePromise;\n            case 22:\n              _context8.t3 = _context8.sent;\n              _context8.t4 = Worker;\n              _context8.t2 = _context8.t3 instanceof _context8.t4;\n            case 25:\n              _context8.t5 = _context8.t2;\n              if (_context8.t5) {\n                _context8.next = 28;\n                break;\n              }\n              _this4._qrEnginePromise = e.createQrEngine();\n            case 28:\n              c ? (_this4._onDecode ? _this4._onDecode(c) : _this4._legacyOnDecode && _this4._legacyOnDecode(c.data), _this4.$codeOutlineHighlight && (clearTimeout(_this4._codeOutlineHighlightRemovalTimeout), _this4._codeOutlineHighlightRemovalTimeout = void 0, _this4.$codeOutlineHighlight.setAttribute(\"viewBox\", \"\".concat(_this4._scanRegion.x || 0, \" \") + \"\".concat(_this4._scanRegion.y || 0, \" \") + \"\".concat(_this4._scanRegion.width || _this4.$video.videoWidth, \" \") + \"\".concat(_this4._scanRegion.height || _this4.$video.videoHeight)), _this4.$codeOutlineHighlight.firstElementChild.setAttribute(\"points\", c.cornerPoints.map(function (_ref2) {\n                var d = _ref2.x,\n                  f = _ref2.y;\n                return \"\".concat(d, \",\").concat(f);\n              }).join(\" \")), _this4.$codeOutlineHighlight.style.display = \"\")) : _this4.$codeOutlineHighlight && !_this4._codeOutlineHighlightRemovalTimeout && (_this4._codeOutlineHighlightRemovalTimeout = setTimeout(function () {\n                return _this4.$codeOutlineHighlight.style.display = \"none\";\n              }, 100));\n            case 29:\n              _this4._scanFrame();\n            case 30:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, null, [[7, 13]]);\n      })));\n    }\n  }, {\n    key: \"_onDecodeError\",\n    value: function _onDecodeError(a) {\n      a !== e.NO_QR_CODE_FOUND && console.log(a);\n    }\n  }, {\n    key: \"_getCameraStream\",\n    value: function () {\n      var _getCameraStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this5 = this;\n        var a, b, c, _i, _arr, d, f, h;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (navigator.mediaDevices) {\n                _context9.next = 2;\n                break;\n              }\n              throw \"Camera not found.\";\n            case 2:\n              a = /^(environment|user)$/.test(this._preferredCamera) ? \"facingMode\" : \"deviceId\", b = [{\n                width: {\n                  min: 1024\n                }\n              }, {\n                width: {\n                  min: 768\n                }\n              }, {}], c = b.map(function (d) {\n                return Object.assign({}, d, _defineProperty({}, a, {\n                  exact: _this5._preferredCamera\n                }));\n              });\n              _i = 0, _arr = [].concat(_toConsumableArray(c), b);\n            case 4:\n              if (!(_i < _arr.length)) {\n                _context9.next = 19;\n                break;\n              }\n              d = _arr[_i];\n              _context9.prev = 6;\n              _context9.next = 9;\n              return navigator.mediaDevices.getUserMedia({\n                video: d,\n                audio: !1\n              });\n            case 9:\n              f = _context9.sent;\n              h = this._getFacingMode(f) || (d.facingMode ? this._preferredCamera : \"environment\" === this._preferredCamera ? \"user\" : \"environment\");\n              return _context9.abrupt(\"return\", {\n                stream: f,\n                facingMode: h\n              });\n            case 14:\n              _context9.prev = 14;\n              _context9.t0 = _context9[\"catch\"](6);\n            case 16:\n              _i++;\n              _context9.next = 4;\n              break;\n            case 19:\n              throw \"Camera not found.\";\n            case 20:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[6, 14]]);\n      }));\n      function _getCameraStream() {\n        return _getCameraStream2.apply(this, arguments);\n      }\n      return _getCameraStream;\n    }()\n  }, {\n    key: \"_restartVideoStream\",\n    value: function () {\n      var _restartVideoStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var a;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              a = this._paused;\n              _context10.next = 3;\n              return this.pause(!0);\n            case 3:\n              _context10.t1 = _context10.sent;\n              if (!_context10.t1) {\n                _context10.next = 6;\n                break;\n              }\n              _context10.t1 = !a;\n            case 6:\n              _context10.t0 = _context10.t1;\n              if (!_context10.t0) {\n                _context10.next = 9;\n                break;\n              }\n              _context10.t0 = this._active;\n            case 9:\n              _context10.t2 = _context10.t0;\n              if (!_context10.t2) {\n                _context10.next = 13;\n                break;\n              }\n              _context10.next = 13;\n              return this.start();\n            case 13:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function _restartVideoStream() {\n        return _restartVideoStream2.apply(this, arguments);\n      }\n      return _restartVideoStream;\n    }()\n  }, {\n    key: \"_setVideoMirror\",\n    value: function _setVideoMirror(a) {\n      this.$video.style.transform = \"scaleX(\" + (\"user\" === a ? -1 : 1) + \")\";\n    }\n  }, {\n    key: \"_getFacingMode\",\n    value: function _getFacingMode(a) {\n      return (a = a.getVideoTracks()[0]) ? /rear|back|environment/i.test(a.label) ? \"environment\" : /front|user|face/i.test(a.label) ? \"user\" : null : null;\n    }\n  }], [{\n    key: \"WORKER_PATH\",\n    set: function set(a) {\n      console.warn(\"Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.\");\n    }\n  }, {\n    key: \"hasCamera\",\n    value: function () {\n      var _hasCamera = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.prev = 0;\n              _context11.next = 3;\n              return e.listCameras(!1);\n            case 3:\n              return _context11.abrupt(\"return\", !!_context11.sent.length);\n            case 6:\n              _context11.prev = 6;\n              _context11.t0 = _context11[\"catch\"](0);\n              return _context11.abrupt(\"return\", !1);\n            case 9:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, null, [[0, 6]]);\n      }));\n      function hasCamera() {\n        return _hasCamera.apply(this, arguments);\n      }\n      return hasCamera;\n    }()\n  }, {\n    key: \"listCameras\",\n    value: function () {\n      var _listCameras = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var a,\n          b,\n          c,\n          _args13 = arguments;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              a = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : !1;\n              if (navigator.mediaDevices) {\n                _context13.next = 3;\n                break;\n              }\n              return _context13.abrupt(\"return\", []);\n            case 3:\n              b = /*#__PURE__*/function () {\n                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n                  return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n                    while (1) switch (_context12.prev = _context12.next) {\n                      case 0:\n                        _context12.next = 2;\n                        return navigator.mediaDevices.enumerateDevices();\n                      case 2:\n                        return _context12.abrupt(\"return\", _context12.sent.filter(function (d) {\n                          return \"videoinput\" === d.kind;\n                        }));\n                      case 3:\n                      case \"end\":\n                        return _context12.stop();\n                    }\n                  }, _callee12);\n                }));\n                return function b() {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n              _context13.prev = 4;\n              _context13.t0 = a;\n              if (!_context13.t0) {\n                _context13.next = 10;\n                break;\n              }\n              _context13.next = 9;\n              return b();\n            case 9:\n              _context13.t0 = _context13.sent.every(function (d) {\n                return !d.label;\n              });\n            case 10:\n              _context13.t1 = _context13.t0;\n              if (!_context13.t1) {\n                _context13.next = 15;\n                break;\n              }\n              _context13.next = 14;\n              return navigator.mediaDevices.getUserMedia({\n                audio: !1,\n                video: !0\n              });\n            case 14:\n              c = _context13.sent;\n            case 15:\n              _context13.next = 19;\n              break;\n            case 17:\n              _context13.prev = 17;\n              _context13.t2 = _context13[\"catch\"](4);\n            case 19:\n              _context13.prev = 19;\n              _context13.next = 22;\n              return b();\n            case 22:\n              return _context13.abrupt(\"return\", _context13.sent.map(function (d, f) {\n                return {\n                  id: d.deviceId,\n                  label: d.label || (0 === f ? \"Default Camera\" : \"Camera \".concat(f + 1))\n                };\n              }));\n            case 23:\n              _context13.prev = 23;\n              c && (console.warn(\"Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream\"), e._stopVideoStream(c));\n              return _context13.finish(23);\n            case 26:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, null, [[4, 17], [19,, 23, 26]]);\n      }));\n      function listCameras() {\n        return _listCameras.apply(this, arguments);\n      }\n      return listCameras;\n    }()\n  }, {\n    key: \"scanImage\",\n    value: function () {\n      var _scanImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(a, b, c, d) {\n        var f,\n          h,\n          m,\n          n,\n          p,\n          k,\n          _yield$Promise$all,\n          _yield$Promise$all2,\n          _e$_drawToCanvas,\n          _e$_drawToCanvas2,\n          q,\n          g,\n          _k,\n          _args15 = arguments;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              f = _args15.length > 4 && _args15[4] !== undefined ? _args15[4] : !1;\n              h = _args15.length > 5 && _args15[5] !== undefined ? _args15[5] : !1;\n              n = !1;\n              b && (\"scanRegion\" in b || \"qrEngine\" in b || \"canvas\" in b || \"disallowCanvasResizing\" in b || \"alsoTryWithoutScanRegion\" in b || \"returnDetailedScanResult\" in b) ? (m = b.scanRegion, c = b.qrEngine, d = b.canvas, f = b.disallowCanvasResizing || !1, h = b.alsoTryWithoutScanRegion || !1, n = !0) : b || c || d || f || h ? console.warn(\"You're using a deprecated api for scanImage which will be removed in the future.\") : console.warn(\"Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.\");\n              b = !!c;\n              _context15.prev = 5;\n              _context15.next = 8;\n              return Promise.all([c || e.createQrEngine(), e._loadImage(a)]);\n            case 8:\n              _yield$Promise$all = _context15.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              c = _yield$Promise$all2[0];\n              p = _yield$Promise$all2[1];\n              _e$_drawToCanvas = e._drawToCanvas(p, m, d, f);\n              _e$_drawToCanvas2 = _slicedToArray(_e$_drawToCanvas, 2);\n              d = _e$_drawToCanvas2[0];\n              k = _e$_drawToCanvas2[1];\n              if (!(c instanceof Worker)) {\n                _context15.next = 24;\n                break;\n              }\n              g = c;\n              b || e._postWorkerMessageSync(g, \"inversionMode\", \"both\");\n              _context15.next = 21;\n              return new Promise(function (l, v) {\n                var w,\n                  _u,\n                  _r,\n                  y = -1;\n                _u = function u(t) {\n                  t.data.id === y && (g.removeEventListener(\"message\", _u), g.removeEventListener(\"error\", _r), clearTimeout(w), null !== t.data.data ? l({\n                    data: t.data.data,\n                    cornerPoints: e._convertPoints(t.data.cornerPoints, m)\n                  }) : v(e.NO_QR_CODE_FOUND));\n                };\n                _r = function r(t) {\n                  g.removeEventListener(\"message\", _u);\n                  g.removeEventListener(\"error\", _r);\n                  clearTimeout(w);\n                  v(\"Scanner error: \" + (t ? t.message || t : \"Unknown Error\"));\n                };\n                g.addEventListener(\"message\", _u);\n                g.addEventListener(\"error\", _r);\n                w = setTimeout(function () {\n                  return _r(\"timeout\");\n                }, 1E4);\n                var x = k.getImageData(0, 0, d.width, d.height);\n                y = e._postWorkerMessageSync(g, \"decode\", x, [x.data.buffer]);\n              });\n            case 21:\n              q = _context15.sent;\n              _context15.next = 27;\n              break;\n            case 24:\n              _context15.next = 26;\n              return Promise.race([new Promise(function (g, l) {\n                return window.setTimeout(function () {\n                  return l(\"Scanner error: timeout\");\n                }, 1E4);\n              }), _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n                var _yield$c$detect, _yield$c$detect2, g;\n                return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n                  while (1) switch (_context14.prev = _context14.next) {\n                    case 0:\n                      _context14.prev = 0;\n                      _context14.next = 3;\n                      return c.detect(d);\n                    case 3:\n                      _yield$c$detect = _context14.sent;\n                      _yield$c$detect2 = _slicedToArray(_yield$c$detect, 1);\n                      g = _yield$c$detect2[0];\n                      if (g) {\n                        _context14.next = 8;\n                        break;\n                      }\n                      throw e.NO_QR_CODE_FOUND;\n                    case 8:\n                      return _context14.abrupt(\"return\", {\n                        data: g.rawValue,\n                        cornerPoints: e._convertPoints(g.cornerPoints, m)\n                      });\n                    case 11:\n                      _context14.prev = 11;\n                      _context14.t0 = _context14[\"catch\"](0);\n                      g = _context14.t0.message || _context14.t0;\n                      if (!/not implemented|service unavailable/.test(g)) {\n                        _context14.next = 16;\n                        break;\n                      }\n                      return _context14.abrupt(\"return\", (e._disableBarcodeDetector = !0, e.scanImage(a, {\n                        scanRegion: m,\n                        canvas: d,\n                        disallowCanvasResizing: f,\n                        alsoTryWithoutScanRegion: h\n                      })));\n                    case 16:\n                      throw \"Scanner error: \".concat(g);\n                    case 17:\n                    case \"end\":\n                      return _context14.stop();\n                  }\n                }, _callee14, null, [[0, 11]]);\n              }))()]);\n            case 26:\n              q = _context15.sent;\n            case 27:\n              return _context15.abrupt(\"return\", n ? q : q.data);\n            case 30:\n              _context15.prev = 30;\n              _context15.t0 = _context15[\"catch\"](5);\n              if (!(!m || !h)) {\n                _context15.next = 34;\n                break;\n              }\n              throw _context15.t0;\n            case 34:\n              _context15.next = 36;\n              return e.scanImage(a, {\n                qrEngine: c,\n                canvas: d,\n                disallowCanvasResizing: f\n              });\n            case 36:\n              _k = _context15.sent;\n              return _context15.abrupt(\"return\", n ? _k : _k.data);\n            case 38:\n              _context15.prev = 38;\n              b || e._postWorkerMessage(c, \"close\");\n              return _context15.finish(38);\n            case 41:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, null, [[5, 30, 38, 41]]);\n      }));\n      function scanImage(_x2, _x3, _x4, _x5) {\n        return _scanImage.apply(this, arguments);\n      }\n      return scanImage;\n    }()\n  }, {\n    key: \"createQrEngine\",\n    value: function () {\n      var _createQrEngine = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(a) {\n        var b;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              a && console.warn(\"Specifying a worker path is not required and not supported anymore.\");\n              a = function a() {\n                return import(\"./qr-scanner-worker.min.js\").then(function (c) {\n                  return c.createWorker();\n                });\n              };\n              _context16.t0 = !e._disableBarcodeDetector && \"BarcodeDetector\" in window && BarcodeDetector.getSupportedFormats;\n              if (!_context16.t0) {\n                _context16.next = 7;\n                break;\n              }\n              _context16.next = 6;\n              return BarcodeDetector.getSupportedFormats();\n            case 6:\n              _context16.t0 = _context16.sent.includes(\"qr_code\");\n            case 7:\n              if (_context16.t0) {\n                _context16.next = 9;\n                break;\n              }\n              return _context16.abrupt(\"return\", a());\n            case 9:\n              b = navigator.userAgentData;\n              _context16.t1 = b && b.brands.some(function (_ref5) {\n                var c = _ref5.brand;\n                return /Chromium/i.test(c);\n              }) && /mac ?OS/i.test(b.platform);\n              if (!_context16.t1) {\n                _context16.next = 15;\n                break;\n              }\n              _context16.next = 14;\n              return b.getHighEntropyValues([\"architecture\", \"platformVersion\"]).then(function (_ref6) {\n                var c = _ref6.architecture,\n                  d = _ref6.platformVersion;\n                return /arm/i.test(c || \"arm\") && 13 <= parseInt(d || \"13\");\n              }).catch(function () {\n                return !0;\n              });\n            case 14:\n              _context16.t1 = _context16.sent;\n            case 15:\n              if (!_context16.t1) {\n                _context16.next = 19;\n                break;\n              }\n              _context16.t2 = a();\n              _context16.next = 20;\n              break;\n            case 19:\n              _context16.t2 = new BarcodeDetector({\n                formats: [\"qr_code\"]\n              });\n            case 20:\n              return _context16.abrupt(\"return\", _context16.t2);\n            case 21:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16);\n      }));\n      function createQrEngine(_x6) {\n        return _createQrEngine.apply(this, arguments);\n      }\n      return createQrEngine;\n    }()\n  }, {\n    key: \"_convertPoints\",\n    value: function _convertPoints(a, b) {\n      if (!b) return a;\n      var c = b.x || 0,\n        d = b.y || 0,\n        f = b.width && b.downScaledWidth ? b.width / b.downScaledWidth : 1;\n      b = b.height && b.downScaledHeight ? b.height / b.downScaledHeight : 1;\n      var _iterator = _createForOfIteratorHelper(a),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var h = _step.value;\n          h.x = h.x * f + c, h.y = h.y * b + d;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return a;\n    }\n  }, {\n    key: \"_stopVideoStream\",\n    value: function _stopVideoStream(a) {\n      var _iterator2 = _createForOfIteratorHelper(a.getTracks()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var b = _step2.value;\n          b.stop(), a.removeTrack(b);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"_drawToCanvas\",\n    value: function _drawToCanvas(a, b, c) {\n      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n      c = c || document.createElement(\"canvas\");\n      var f = b && b.x ? b.x : 0,\n        h = b && b.y ? b.y : 0,\n        m = b && b.width ? b.width : a.videoWidth || a.width,\n        n = b && b.height ? b.height : a.videoHeight || a.height;\n      d || (d = b && b.downScaledWidth ? b.downScaledWidth : m, b = b && b.downScaledHeight ? b.downScaledHeight : n, c.width !== d && (c.width = d), c.height !== b && (c.height = b));\n      b = c.getContext(\"2d\", {\n        alpha: !1\n      });\n      b.imageSmoothingEnabled = !1;\n      b.drawImage(a, f, h, m, n, 0, 0, c.width, c.height);\n      return [c, b];\n    }\n  }, {\n    key: \"_loadImage\",\n    value: function () {\n      var _loadImage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(a) {\n        var b;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!(a instanceof Image)) {\n                _context17.next = 4;\n                break;\n              }\n              _context17.next = 3;\n              return e._awaitImageLoad(a);\n            case 3:\n              return _context17.abrupt(\"return\", a);\n            case 4:\n              if (!(a instanceof HTMLVideoElement || a instanceof HTMLCanvasElement || a instanceof SVGImageElement || \"OffscreenCanvas\" in window && a instanceof OffscreenCanvas || \"ImageBitmap\" in window && a instanceof ImageBitmap)) {\n                _context17.next = 6;\n                break;\n              }\n              return _context17.abrupt(\"return\", a);\n            case 6:\n              if (!(a instanceof File || a instanceof Blob || a instanceof URL || \"string\" === typeof a)) {\n                _context17.next = 18;\n                break;\n              }\n              b = new Image();\n              b.src = a instanceof File || a instanceof Blob ? URL.createObjectURL(a) : a.toString();\n              _context17.prev = 9;\n              _context17.next = 12;\n              return e._awaitImageLoad(b);\n            case 12:\n              return _context17.abrupt(\"return\", b);\n            case 13:\n              _context17.prev = 13;\n              (a instanceof File || a instanceof Blob) && URL.revokeObjectURL(b.src);\n              return _context17.finish(13);\n            case 16:\n              _context17.next = 19;\n              break;\n            case 18:\n              throw \"Unsupported image type.\";\n            case 19:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, null, [[9,, 13, 16]]);\n      }));\n      function _loadImage(_x7) {\n        return _loadImage2.apply(this, arguments);\n      }\n      return _loadImage;\n    }()\n  }, {\n    key: \"_awaitImageLoad\",\n    value: function () {\n      var _awaitImageLoad2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(a) {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.t0 = a.complete && 0 !== a.naturalWidth;\n              if (_context18.t0) {\n                _context18.next = 4;\n                break;\n              }\n              _context18.next = 4;\n              return new Promise(function (b, c) {\n                var d = function d(f) {\n                  a.removeEventListener(\"load\", d);\n                  a.removeEventListener(\"error\", d);\n                  f instanceof ErrorEvent ? c(\"Image load error\") : b();\n                };\n                a.addEventListener(\"load\", d);\n                a.addEventListener(\"error\", d);\n              });\n            case 4:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18);\n      }));\n      function _awaitImageLoad(_x8) {\n        return _awaitImageLoad2.apply(this, arguments);\n      }\n      return _awaitImageLoad;\n    }()\n  }, {\n    key: \"_postWorkerMessage\",\n    value: function () {\n      var _postWorkerMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(a, b, c, d) {\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.t0 = e;\n              _context19.next = 3;\n              return a;\n            case 3:\n              _context19.t1 = _context19.sent;\n              _context19.t2 = b;\n              _context19.t3 = c;\n              _context19.t4 = d;\n              return _context19.abrupt(\"return\", _context19.t0._postWorkerMessageSync.call(_context19.t0, _context19.t1, _context19.t2, _context19.t3, _context19.t4));\n            case 8:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19);\n      }));\n      function _postWorkerMessage(_x9, _x10, _x11, _x12) {\n        return _postWorkerMessage2.apply(this, arguments);\n      }\n      return _postWorkerMessage;\n    }()\n  }, {\n    key: \"_postWorkerMessageSync\",\n    value: function _postWorkerMessageSync(a, b, c, d) {\n      if (!(a instanceof Worker)) return -1;\n      var f = e._workerMessageId++;\n      a.postMessage({\n        id: f,\n        type: b,\n        data: c\n      }, d);\n      return f;\n    }\n  }]);\n  return e;\n}();\ne.DEFAULT_CANVAS_SIZE = 400;\ne.NO_QR_CODE_FOUND = \"No QR code found\";\ne._disableBarcodeDetector = !1;\ne._workerMessageId = 0;\nexport default e;","map":{"version":3,"sources":["src/qr-scanner.ts"],"names":["QrScanner","workerPath","console","warn","hasCamera","listCameras","length","requestLabels","navigator","mediaDevices","filter","device","enumerateCameras","every","camera","label","openedStream","getUserMedia","audio","video","map","i","id","deviceId","_stopVideoStream","DEFAULT_CANVAS_SIZE","constructor","onDecode","$video","$canvas","document","createElement","_onDecode","_legacyOnDecode","canvasSizeOrOnDecodeErrorOrOptions","_onDecodeError","options","onDecodeError","_calculateScanRegion","calculateScanRegion","canvasSizeOrCalculateScanRegion","_preferredCamera","preferredCamera","_legacyCanvasSize","_maxScansPerSecond","maxScansPerSecond","_onPlay","bind","_onLoadedMetaData","_onVisibilityChange","_updateOverlay","disablePictureInPicture","playsInline","muted","shouldHideVideo","hidden","body","contains","appendChild","highlightScanRegion","highlightCodeOutline","$overlay","overlay","overlayStyle","position","display","pointerEvents","classList","add","gotExternalOverlay","innerHTML","firstElementChild","animate","transform","duration","iterations","Infinity","direction","easing","e","videoContainer","insertBefore","nextSibling","insertAdjacentHTML","$codeOutlineHighlight","lastElementChild","_scanRegion","requestAnimationFrame","videoStyle","style","setProperty","visibility","opacity","width","height","parentElement","removeChild","addEventListener","window","_qrEnginePromise","createQrEngine","hasFlash","srcObject","MediaStream","stream","_getCameraStream","getVideoTracks","getSettings","isFlashOn","_flashOn","toggleFlash","turnFlashOff","turnFlashOn","_destroyed","_active","_paused","applyConstraints","advanced","torch","_restartVideoStream","destroy","removeEventListener","stop","_postWorkerMessage","start","Error","location","protocol","play","_setVideoMirror","facingMode","catch","pause","stopStreamImmediately","stopStream","Promise","resolve","setTimeout","setCamera","facingModeOrDeviceId","scanImage","imageOrFileOrBlobOrUrl","scanRegionOrOptions","qrEngine","canvas","disallowCanvasResizing","alsoTryWithoutScanRegion","returnDetailedScanResult","scanRegion","image","all","_loadImage","canvasContext","_drawToCanvas","Worker","gotExternalEngine","_postWorkerMessageSync","qrEngineWorker","detailedScanResult","reject","timeout","onMessage","onError","expectedResponseId","event","data","clearTimeout","cornerPoints","_convertPoints","NO_QR_CODE_FOUND","error","imageData","buffer","race","scanResult","rawValue","message","test","errorMessage","_disableBarcodeDetector","setGrayscaleWeights","red","green","blue","useIntegerApproximation","setInversionMode","inversionMode","then","module","createWorker","BarcodeDetector","getSupportedFormats","includes","userAgentData","brands","some","brand","platform","getHighEntropyValues","architecture","parseInt","platformVersion","formats","_scanFrame","x","Math","round","videoWidth","scanRegionSize","y","videoHeight","downScaledWidth","downScaledHeight","videoObjectFit","videoScaledWidth","elementWidth","videoScaledHeight","elementHeight","videoAspectRatio","elementAspectRatio","min","videoY","lengthValue","parseFloat","endsWith","regionWidth","regionHeight","top","elementY","regionY","left","elementX","isVideoMirrored","videoX","regionX","points","point","scaleFactorX","offsetX","scaleFactorY","offsetY","paused","ended","requestVideoFrameCallback","readyState","timeSinceLastScan","minimumTimeBetweenScans","_lastScanTimestamp","Date","now","result","_codeOutlineHighlightRemovalTimeout","undefined","setAttribute","join","log","constraint","preferenceType","exact","constraints","wasPaused","track","removeTrack","_getFacingMode","videoStream","videoTrack","scanRegionWidth","scanRegionHeight","canvasWidth","canvasHeight","alpha","context","imageSmoothingEnabled","drawImage","scanRegionX","scanRegionY","Image","_awaitImageLoad","HTMLVideoElement","HTMLCanvasElement","SVGImageElement","OffscreenCanvas","ImageBitmap","File","Blob","URL","src","createObjectURL","toString","revokeObjectURL","complete","naturalWidth","listener","ErrorEvent","qrEngineOrQrEnginePromise","type","transfer","postMessage"],"mappings":"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","sourcesContent":["class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    private static _disableBarcodeDetector = false;\n    private static _workerMessageId = 0;\n\n    /** @deprecated */\n    static set WORKER_PATH(workerPath: string) {\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\n            + 'Have a look at the README for new setup instructions.');\n    }\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\n        // ask for camera permission by opening a stream.\n        let openedStream: MediaStream | undefined;\n        try {\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            }\n        } catch (e) {\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\n            // and some browsers disallow a second stream.\n        }\n\n        try {\n            return (await enumerateCameras()).map((camera, i) => ({\n                id: camera.deviceId,\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(openedStream);\n            }\n        }\n    }\n\n    readonly $video: HTMLVideoElement;\n    readonly $canvas: HTMLCanvasElement;\n    readonly $overlay?: HTMLDivElement;\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\n    private readonly _legacyOnDecode?: (result: string) => void;\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\n    private readonly _maxScansPerSecond: number = 25;\n    private _lastScanTimestamp: number = -1;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _codeOutlineHighlightRemovalTimeout?: number;\n    private _qrEnginePromise: Promise<Worker | BarcodeDetector>\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n    private _destroyed: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: QrScanner.ScanResult) => void,\n        options: {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\n            // we got an options object using the new api\n            this._onDecode = onDecode as QrScanner['_onDecode'];\n        } else {\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                    + 'the future');\n            } else {\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\n                // if an options object was provided. However, in the future once legacy support is removed, the options\n                // object should become optional.\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\n            }\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\n        }\n\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : {};\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : this._onDecodeError);\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\n            ? canvasSizeOrCalculateScanRegion\n            : this._calculateScanRegion);\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\n                ? canvasSizeOrCalculateScanRegion\n                : this._legacyCanvasSize;\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n        this._updateOverlay = this._updateOverlay.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        const videoContainer = video.parentElement!;\n\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\n            const gotExternalOverlay = !!options.overlay;\n            this.$overlay = options.overlay || document.createElement('div');\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.position = 'absolute';\n            overlayStyle.display = 'none';\n            overlayStyle.pointerEvents = 'none';\n            this.$overlay.classList.add('scan-region-highlight');\n            if (!gotExternalOverlay && options.highlightScanRegion) {\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n                try {\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\n                        duration: 400,\n                        iterations: Infinity,\n                        direction: 'alternate',\n                        easing: 'ease-in-out',\n                    });\n                } catch (e) {}\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\n            }\n            if (options.highlightCodeOutline) {\n                // default style; can be overwritten via css\n                this.$overlay.insertAdjacentHTML(\n                    'beforeend',\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\n                );\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\n            }\n        }\n        this._scanRegion = this._calculateScanRegion(video);\n\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const videoStyle = window.getComputedStyle(video);\n            if (videoStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (videoStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n                if (this.$overlay && this.$overlay.parentElement) {\n                    this.$overlay.parentElement.removeChild(this.$overlay);\n                }\n                // @ts-ignore\n                delete this.$overlay!;\n                // @ts-ignore\n                delete this.$codeOutlineHighlight!;\n            }\n\n            if (this.$overlay) {\n                this._updateOverlay();\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n        window.addEventListener('resize', this._updateOverlay);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(stream);\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn || this._destroyed) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n        window.removeEventListener('resize', this._updateOverlay);\n\n        this._destroyed = true;\n        this._flashOn = false;\n        this.stop(); // sets this._paused = true and this._active = false\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            await this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            if (!this._active || this._paused) {\n                // was stopped in the meantime\n                QrScanner._stopVideoStream(stream);\n                return;\n            }\n            this._setVideoMirror(facingMode);\n            this.$video.srcObject = stream;\n            await this.$video.play();\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            if (this._paused) return;\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        if (this.$overlay) {\n            this.$overlay.style.display = 'none';\n        }\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                QrScanner._stopVideoStream(this.$video.srcObject);\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        options: {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    ): Promise<QrScanner.ScanResult>;\n    /** @deprecated */\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing?: boolean,\n        alsoTryWithoutScanRegion?: boolean,\n    ): Promise<string>;\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        } | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string | QrScanner.ScanResult> {\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\n        let returnDetailedScanResult = false;\n        if (scanRegionOrOptions && (\n            'scanRegion' in scanRegionOrOptions\n            || 'qrEngine' in scanRegionOrOptions\n            || 'canvas' in scanRegionOrOptions\n            || 'disallowCanvasResizing' in scanRegionOrOptions\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\n            || 'returnDetailedScanResult' in scanRegionOrOptions\n        )) {\n            // we got an options object using the new api\n            scanRegion = scanRegionOrOptions.scanRegion;\n            qrEngine = scanRegionOrOptions.qrEngine;\n            canvas = scanRegionOrOptions.canvas;\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\n            returnDetailedScanResult = true;\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\n        } else {\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\n            // an options object was provided. However, in the future once legacy support is removed, the options object\n            // should become optional.\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\n                + 'new api today, you can pass returnDetailedScanResult: true.');\n        }\n\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n            [qrEngine, image] = await Promise.all([\n                qrEngine || QrScanner.createQrEngine(),\n                QrScanner._loadImage(imageOrFileOrBlobOrUrl),\n            ]);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n            let detailedScanResult: QrScanner.ScanResult;\n\n            if (qrEngine instanceof Worker) {\n                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners\n                if (!gotExternalEngine) {\n                    // Enable scanning of inverted color qr codes.\n                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');\n                }\n                detailedScanResult = await new Promise((resolve, reject) => {\n                    let timeout: number;\n                    let onMessage: (event: MessageEvent) => void;\n                    let onError: (error: ErrorEvent | string) => void;\n                    let expectedResponseId = -1;\n                    onMessage = (event: MessageEvent) => {\n                        if (event.data.id !== expectedResponseId) {\n                            return;\n                        }\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve({\n                                data: event.data.data,\n                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\n                            });\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (error: ErrorEvent | string) => {\n                        qrEngineWorker.removeEventListener('message', onMessage);\n                        qrEngineWorker.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngineWorker.addEventListener('message', onMessage);\n                    qrEngineWorker.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                    expectedResponseId = QrScanner._postWorkerMessageSync(\n                        qrEngineWorker,\n                        'decode',\n                        imageData,\n                        [imageData.data.buffer],\n                    );\n                });\n            } else {\n                detailedScanResult = await Promise.race([\n                    new Promise<QrScanner.ScanResult>((resolve, reject) => window.setTimeout(\n                        () => reject('Scanner error: timeout'),\n                        10000,\n                    )),\n                    (async (): Promise<QrScanner.ScanResult> => {\n                        try {\n                            const [scanResult] = await qrEngine.detect(canvas!);\n                            if (!scanResult) throw QrScanner.NO_QR_CODE_FOUND;\n                            return {\n                                data: scanResult.rawValue,\n                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),\n                            };\n                        } catch (e) {\n                            const errorMessage = (e as Error).message || e as string;\n                            if (/not implemented|service unavailable/.test(errorMessage)) {\n                                // Not implemented can apparently for some reason happen even though getSupportedFormats\n                                // in createQrScanner reported that it's supported, see issue #98.\n                                // Service unavailable can happen after some time when the BarcodeDetector crashed and\n                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in\n                                // newer browsers this issue does not seem to be present anymore and therefore we do not\n                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.\n                                // Also note that if we got an external qrEngine that crashed, we should possibly notify\n                                // the caller about it, but we also don't do this here, as it's such an unlikely case.\n                                QrScanner._disableBarcodeDetector = true;\n                                // retry without passing the broken BarcodeScanner instance\n                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {\n                                    scanRegion,\n                                    canvas,\n                                    disallowCanvasResizing,\n                                    alsoTryWithoutScanRegion,\n                                });\n                            }\n                            throw `Scanner error: ${errorMessage}`;\n                        }\n                    })(),\n                ]);\n            }\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            const detailedScanResult = await QrScanner.scanImage(\n                imageOrFileOrBlobOrUrl,\n                { qrEngine, canvas, disallowCanvasResizing },\n            );\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } finally {\n            if (!gotExternalEngine) {\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations work also well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations scan normal and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    static async createQrEngine(): Promise<Worker | BarcodeDetector>;\n    /** @deprecated */\n    static async createQrEngine(workerPath: string): Promise<Worker | BarcodeDetector>;\n    static async createQrEngine(workerPath?: string): Promise<Worker | BarcodeDetector> {\n        if (workerPath) {\n            console.warn('Specifying a worker path is not required and not supported anymore.');\n        }\n\n        // @ts-ignore no types defined for import\n        const createWorker = () => (import('./qr-scanner-worker.min.js') as Promise<{ createWorker: () => Worker }>)\n            .then((module) => module.createWorker());\n\n        const useBarcodeDetector = !QrScanner._disableBarcodeDetector\n            && 'BarcodeDetector' in window\n            && BarcodeDetector.getSupportedFormats\n            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');\n\n        if (!useBarcodeDetector) return createWorker();\n\n        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in\n        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not\n        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.\n        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442\n        // TODO update this once the issue in macOS is fixed\n        const userAgentData = navigator.userAgentData;\n        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData\n            && userAgentData.brands.some(({ brand }) => /Chromium/i.test(brand))\n            && /mac ?OS/i.test(userAgentData.platform)\n            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can\n            // theoretically trigger a browser prompt, although no browser currently does seem to show one.\n            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.\n            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])\n                .then(({ architecture, platformVersion }) =>\n                    /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)\n                .catch(() => true);\n        if (isChromiumOnMacWithArmVentura) return createWorker();\n\n        return new BarcodeDetector({ formats: ['qr_code'] });\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n        if (this.$overlay) {\n            this.$overlay.style.display = '';\n        }\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _updateOverlay(): void {\n        requestAnimationFrame(() => {\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\n            if (!this.$overlay) return;\n            const video = this.$video;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            const elementWidth = video.offsetWidth;\n            const elementHeight = video.offsetHeight;\n            const elementX = video.offsetLeft;\n            const elementY = video.offsetTop;\n\n            const videoStyle = window.getComputedStyle(video);\n            const videoObjectFit = videoStyle.objectFit;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const elementAspectRatio = elementWidth / elementHeight;\n            let videoScaledWidth: number;\n            let videoScaledHeight: number;\n            switch (videoObjectFit) {\n                case 'none':\n                    videoScaledWidth = videoWidth;\n                    videoScaledHeight = videoHeight;\n                    break;\n                case 'fill':\n                    videoScaledWidth = elementWidth;\n                    videoScaledHeight = elementHeight;\n                    break;\n                default: // 'cover', 'contains', 'scale-down'\n                    if (videoObjectFit === 'cover'\n                        ? videoAspectRatio > elementAspectRatio\n                        : videoAspectRatio < elementAspectRatio) {\n                        // The scaled height is the element height\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\n                        //   (scaled height matches element height and scaled width overflows element width)\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\n                        //   (scaled height matched element height and element width overflows scaled width)\n                        videoScaledHeight = elementHeight;\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\n                    } else {\n                        videoScaledWidth = elementWidth;\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\n                    }\n                    if (videoObjectFit === 'scale-down') {\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\n                    }\n            }\n\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\n                const lengthValue = parseFloat(length);\n                return length.endsWith('%')\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\n                    : lengthValue;\n            });\n\n            const regionWidth = this._scanRegion.width || videoWidth;\n            const regionHeight = this._scanRegion.height || videoHeight;\n            const regionX = this._scanRegion.x || 0;\n            const regionY = this._scanRegion.y || 0;\n\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\n            overlayStyle.left = `${elementX\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\n            // apply same mirror as on video\n            overlayStyle.transform = video.style.transform;\n        });\n    }\n\n    private static _convertPoints(\n        points: QrScanner.Point[],\n        scanRegion?: QrScanner.ScanRegion | null,\n    ): QrScanner.Point[] {\n        if (!scanRegion) return points;\n        const offsetX = scanRegion.x || 0;\n        const offsetY = scanRegion.y || 0;\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\n            ? scanRegion.width / scanRegion.downScaledWidth\n            : 1;\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\n            ? scanRegion.height / scanRegion.downScaledHeight\n            : 1;\n        for (const point of points) {\n            point.x = point.x * scaleFactorX + offsetX;\n            point.y = point.y * scaleFactorY + offsetY;\n        }\n        return points;\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\n        // being fired if the tab is in the background, which is what we want.\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\n            // @ts-ignore\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\n            : requestAnimationFrame;\n        requestFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\n            }\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\n            this._lastScanTimestamp = Date.now();\n\n            let result: QrScanner.ScanResult | undefined;\n            try {\n                result = await QrScanner.scanImage(this.$video, {\n                    scanRegion: this._scanRegion,\n                    qrEngine: this._qrEnginePromise,\n                    canvas: this.$canvas,\n                });\n            } catch (error) {\n                if (!this._active) return;\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {\n                // replace the disabled BarcodeDetector\n                this._qrEnginePromise = QrScanner.createQrEngine();\n            }\n\n            if (result) {\n                if (this._onDecode) {\n                    this._onDecode(result);\n                } else if (this._legacyOnDecode) {\n                    this._legacyOnDecode(result.data);\n                }\n\n                if (this.$codeOutlineHighlight) {\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\n                    this.$codeOutlineHighlight.setAttribute(\n                        'viewBox',\n                        `${this._scanRegion.x || 0} `\n                            + `${this._scanRegion.y || 0} `\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\n                    );\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\n                    this.$codeOutlineHighlight.style.display = '';\n                }\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\n                    100,\n                );\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private static _stopVideoStream(stream : MediaStream): void {\n        for (const track of stream.getTracks()) {\n            track.stop(); //  note that this will also automatically turn the flashlight off\n            stream.removeTrack(track);\n        }\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static async _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector>,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): Promise<number> {\n        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);\n    }\n\n    // sync version of _postWorkerMessage without performance overhead of async functions\n    private static _postWorkerMessageSync(\n        qrEngine: Worker | BarcodeDetector,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        if (!(qrEngine instanceof Worker)) return -1;\n        const id = QrScanner._workerMessageId++;\n        qrEngine.postMessage({\n            id,\n            type,\n            data,\n        }, transfer);\n        return id;\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export interface ScanResult {\n        data: string;\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\n        cornerPoints: QrScanner.Point[];\n    }\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\n}\n\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\ndeclare global {\n    interface Navigator {\n        readonly userAgentData?: {\n            readonly platform: string;\n            readonly brands: Array<{\n                readonly brand: string;\n                readonly version: string;\n            }>;\n            getHighEntropyValues(hints: string[]): Promise<{\n                readonly architecture?: string;\n                readonly platformVersion?: string;\n            }>;\n        };\n    }\n}\n\nexport default QrScanner;\n"]},"metadata":{},"sourceType":"module"}